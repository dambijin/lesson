<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        //두개의 전달인자를 받아서 더하고
        //더한 값을 돌려주는 함수

        //함수명:sum
        //전달인자 : x, y 둘다 숫자
        //리턴 : x와 y의 합
        function sum(x, y) {
            console.log(`x: ${x}, y: ${y}`);
            let z = x + y;
            //isNaN() 함수는 어떤 값이 NaN인지 판별한다.
            //매개변수가 숫자가인지 아닌지 검사하며
            //숫자가 아니면 true, 숫자이면 false를 반환한다.
            console.log('isNaN(z) : ', isNaN(z));
            return z;
        }

        let result = sum(10, 20);
        console.log("result : ", result);

        result = sum(15);
        console.log("result : ", result);

        result = sum(100, 200, 300);
        console.log("result : ", result);

        console.log(sum);
        // sum을 변수로 선언하면 변수로 바로 바뀐다.
        // sum=1;
        // console.log(sum);


        //함수안에 함수도 들어갈 수 있고, 변수도 들어갈 수 있다.
        let sum2 = sum;
        console.log(sum2(1, 2));

        //sum에 방어코딩 추가
        function sum3(x, y) {
            console.log(x, y);
            if (x == undefined) {
                x = 0;
            }
            if (y == undefined) {
                y = 0;
            }
            console.log(`x: ${x}, y: ${y}`);
            let z = x + y;
            console.log('isNaN(z) : ', isNaN(z));
            return z;
        }

        sum3();


        // 전달인자가 없으면 이렇게 초기값을 미리 설정하고 함수 설정 가능
        function sum4(x = 0, y = 0) {
            console.log(`x: ${x}, y: ${y}`);
            let z = x + y;
            console.log('isNaN(z) : ', isNaN(z));
            return z;
        }
        sum4(5);

        function sum5() {
            console.log(arguments);
            //for of 문
            //for 변수명 of 배열집합
            //이렇게 사용하면 배열하나씩 변수에 넣어서 사용하는 것이다.
            //아래예제에선 argymnets의 배열 순서대로 arg에 선언이 되는 것이다.
            for (let arg of arguments) {
                console.log(arg);
            }
        }
        sum5(1, 2, 3);

        function sum6(x, ...num) {
            console.log(x, num);
        }
        sum6(1, 2);
        sum6(1, 2, 3, 4);

        console.log('============');
        let a = [1, 2, 3, 4];
        console.log(a);
        console.log(...a);
        sum(...a);

        eval("console.log('----------')");

        console.log(encodeURI('한글'));
        console.log(encodeURI('%ED%95%9C%EA%B8%80'));


        //전달인자로 함수를 전달할 수 있다.
        //그 함수를 callback함수라고 한다.
        //다른 함수가 실행을 끝낸 뒤 실행되는 함수를 callback함수라고 한다.
        
        console.log("-----------콜백함수---------");
        function sum7(cb) {
            console.log(typeof cb)
            if (typeof cb == "function") {
                let result = cb(2, 3);
                console.log(result);
            }
        }
        sum7(sum);

        console.log("-----------익명함수---------");

        //익명함수 function 함수이름 >>이렇게 있어야하지만 함수이름이 없는 함수를 뜻함 
        //익명함수는 많이 사용한다.
        
        let sum8 = function (x, y) {
            return x + y;
        };

        // sum7(sum8)
        sum7(function (x, y) {
            return x + y;
        })

        //arrow function 화살표 함수

        let fn1=function(x,y){
            return x+y;
        }

        fn1=(x,y) => {
            return x+y;
        }
        //전달인자가 하나만 있는 경우 괄호 생략가능
        fn1=x=>{
            return x*x
        }

        //실행블럭의 내용이 딱 한줄인 경우 {}와 return 생략 필수
        fn1=x=>x*x

        fn1=(x,y)=>x+y;

        //첫번째 전달인자 : 콜백함수
        //두번째 전달인자 : 시간(밀리초ms, 1000ms = 1s)
        //지정시간 이후 딱 한번만 실행 됨
        let idx1=setTimeout(function(){
            console.log("print 1")
        }, 3*1000 )
        console.log("after");
        console.log("idx1 :",idx1);

        //idx1에 해당하는 setTimeout 기능 정지
        clearTimeout(idx1);

        let idx2=setInterval(function(){
            console.log("print2");
        },300)

        clearInterval(idx2);

        let now=new Date().getTime()
        let after=0;
        while(after - now<3000){
            after=new Date().getTime()
            console.log(after-now)
        }
        console.log("print3");

        do{
            console.log("print4")
        }while(false)







    </script>
</head>

<body>

</body>

</html>